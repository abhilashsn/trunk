require 'digest/sha1'

ONLINE = 1
OFFLINE = 0
BUSY = 1
IDLE = 0

class User < ActiveRecord::Base
  
  # Include default devise modules.
  devise :database_authenticatable, :lockable, :trackable, :registerable, :password_expirable,
    :encryptable, :encryptor => :restful_authentication_sha1

  PASSWORD_MIN_LENGTH = 8
  PASSWORD_MAX_LENGTH = 40

  attr_accessible :login, :email, :name, :password, :password_confirmation, :batch_status_permission,  :current_password
  # ---------------------------------------
  # The following code has been generated by role_requirement.
  # You may wish to modify it to suit your need
  #has_and_belongs_to_many :roles
  has_many :roles, :through => :roles_users
  has_many :roles_users
  belongs_to :shift
  has_many :facilities_users
  has_many :facilities, :through => :facilities_users
  has_many :partners_users
  has_many :partners, :through => :partners_users
  has_many :clients_users
  has_many :clients, :through => :clients_users
  has_many :processor_jobs, :class_name => "Job", :foreign_key => "processor_id"
  has_many :qa_jobs, :class_name => "Job", :foreign_key => "qa_id"
  has_many :sqa_jobs, :class_name => "Job", :foreign_key => "sqa_id"

  has_many :processor_eob_qas, :class_name => "EobQa", :foreign_key => "processor_id"
  has_many :qa_eob_qas, :class_name => "EobQa", :foreign_key => "qa_id"
  
  has_many :processor_eob_sqas, :class_name => "EobSqa", :foreign_key => "processor_id"
  has_many :qa_eob_sqas, :class_name => "EobSqa", :foreign_key => "qa_id"
  has_many :sqa_eob_sqas, :class_name => "EobSqa", :foreign_key => "sqa_id"
  
  has_many :hlsc_jobs, :class_name => "Batch", :foreign_key => "hlsc_id"
  has_many :user_payer_job_histories
  # U2R - Useless
  # has_many :certifications
  # has_many :clients, :through => :certifications
  # has_many :user_client_job_histories
  # has_many :clients, :through => :user_client_job_histories  
  
  has_many :members, :class_name => "User", :foreign_key => "teamleader_id"
  belongs_to :teamleader, :class_name => "User", :foreign_key => "teamleader_id"
  has_many :mpi_statistics_reports

  has_many :capitation_accounts 
  has_many :old_passwords
  has_many :user_activity_logs
  has_one :idle_processor
  has_many :error_popups, :class_name => "ErrorPopup", :foreign_key => "processor_id"

  # has_role? simply needs to return true or false whether a user has a role or not.
  # It may be a good idea to have "admin" roles return true always
  def has_role?(role_in_question)
    @_list ||= self.roles.collect(& :name)
    (@_list.include?(role_in_question.to_s))
  end

  def password_changed?
    self.password_salt_changed? && self.encrypted_password_changed?
  end

  validates_presence_of :login
  validates_length_of :login, :within => 3..40
  validates_uniqueness_of :login, :case_sensitive => false, :message => "This Login has already been taken"
  #    validates_format_of :login, :with => RE_LOGIN_OK, :message => MSG_LOGIN_BAD
  validates :name, :presence => true
  #    validates_format_of :name, :with => RE_NAME_OK, :message => MSG_NAME_BAD, :allow_nil => true
  validates_length_of :name, :maximum => 100
  
  validates_presence_of :email
  validates_length_of :email, :within => 6..100 #r@a.wk
  #  validates_presence_of :password
  
  #  validates_uniqueness_of   :email,    :case_sensitive => false
  #    validates_format_of :email, :with => RE_EMAIL_OK, :message => MSG_EMAIL_BAD

  # Length check
  validates_format_of :password,
    :with => Regexp.new("^(.){#{PASSWORD_MIN_LENGTH},#{PASSWORD_MAX_LENGTH}}"),
    :message => "should be between #{PASSWORD_MIN_LENGTH} and #{PASSWORD_MAX_LENGTH} characters", :if => :password_changed?

  validates_format_of :password, :with => /(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\W)|(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*\_)/, 
    :message => 'should contain minimum 1 Upper Case Letter, 1 Lower Case Letter, 1 Numeral and 1 Special Character.', :if => :password_changed?

  validates_presence_of :password, :on => :update, :if => :password_changed?
  validate :password_meets_requirements

  # Validation for Employee ID
  validates_presence_of :employee_id, :message => "ID can't be blank"
  validates :employee_id , :format => { :with => /^[A-Za-z0-9]*$/, :message => "ID should be alphanumeric" }

  after_create :create_password_history

  def lockboxes

    facs = []

    if self.has_role? :partner
      facs = Facility.find(:all,
        :joins =>'inner join clients on clients.id = facilities.client_id
        inner join partners on clients.partner_id = partners.id',
        :conditions => "partners.id in( #{self.partner_ids.join(',')})"
      ) unless self.partner_ids.blank?
    end

    if self.has_role? :client
      facs = Facility.find(:all,
        :joins =>'inner join clients on clients.id = facilities.client_id',
        :conditions => "clients.id in( #{self.client_ids.join(',')})"
      ) unless self.client_ids.blank?
    end

    facs = self.facilities if self.has_role? :facility or self.has_role? :supervisor or self.has_role? :manager or self.has_role? :qa or self.has_role? :processor

    return facs

  end

  def password_meets_requirements
    return true if password.blank?
    # do other password-specific validations here, if any
    if not new_record? and already_used?(password)
      errors[:base] << "Password cannot be one you have used in the past"
    end
  end

  def already_used?(password)
    old_passwords.each do |old|
      return true if old.password_hash == Digest::SHA1.hexdigest(password)
    end
    return false
  end

  def create_password_history
    old_password = OldPassword.new
    old_password.password_hash = Digest::SHA1.hexdigest(password)
    old_password.user_id = id
    old_password.save!
  end

  def self.update_password_history(user_id, password)
    if self.no_password_history(password)
      o = OldPassword.new
      o.user_id = user_id
      o.password_hash =  Digest::SHA1.hexdigest(password)
      o.save
    end

  end

  def self.no_password_history(password)
    password_hash = Digest::SHA1.hexdigest(password)
    OldPassword.all.each do |old|
      return true unless old.password_hash == password_hash
    end
    return false
  end

  #returns client specific per hour eob rate for processor
  def processing_rate_for_client(client)
    if client.name == 'Triad' || client.name == 'Partners' || client.name == 'Childrens'
      return self.processing_rate_triad
    else
      return self.processing_rate_others
    end
  end

  def User.default_processing_rate_for_client(client)
    if client && (client.name == 'Triad' || client.name == 'Partners' || client.name == 'Childrens')
      return 5
    else
      return 8
    end
  end

  def jobs
    if self.role == 'Processor'
      self.processor_jobs
    else
      self.qa_jobs
    end
  end
    
  def self.qa_allocated_job(user)
    job_count = Job.count(:all,:conditions => "qa_id= #{user} and qa_status ='#{QaStatus::ALLOCATED}'")
    return job_count
  end

  #This method is for getting online user names for role as Processsor or QA
  def self.get_online_user_names_for_role(role_name)
    online_users_names = Array.new
    relation_include = [ {:roles_users => :role}]
    condition = "users.login_status = #{ONLINE} and roles.name = '#{role_name}'"
    condition += " and users.auto_allocation_enabled = true" if role_name == 'processor'
   
    online_users = User.find(:all, :conditions => condition ,
      :include => relation_include)

    online_users.each do |user|
      online_users_names << user.name
    end
   
    online_users_names
  end

  # Returns the number of jobs assigned but not completed by the processor
  def count_of_jobs_processing
    Job.count(:all, :conditions => {:processor_id => id, :processor_status => "#{ProcessorStatus::ALLOCATED}"})
  end 
  
  # Updates the user attributes while completing a job
  # Output : saved user object
  def update_processing_attributes(facility_id, count_of_eobs)
    if has_role?(:processor)
      FacilitiesUser.save_eobs_processed(id, facility_id, count_of_eobs)
      if count_of_jobs_processing == 0
        self.allocation_status = IDLE
      end
    end
    self.last_job_completed_at = Time.now
    if self.valid?
      self.save
    end    
    self
  end
     
  def first_login_time_for_day
    current_date = Date.today.strftime('%Y-%m-%d')
    user_activity_log = user_activity_logs.find(:first, :conditions => 
        "activity = 'Logged in' and DATE(performed_at) = '#{current_date}'")
    first_login_time_for_day = user_activity_log.performed_at unless user_activity_log.blank?
  end
  
  def last_logout_time_for_day
    current_date = Date.today.strftime('%Y-%m-%d')
    user_activity_log = user_activity_logs.find(:last, :conditions => 
        "activity = 'Logged out' and DATE(performed_at) = '#{current_date}'")
    last_logout_time_for_day = user_activity_log.performed_at unless user_activity_log.blank?
  end

  def self.track_unsuccessful_login_attempts(login, ip_address)
    user = User.find_by_login(login)
    if user
      role_of_user = user.roles.first.name
      UserActivityLog.create(:user_id => user.id, :activity => "Login failed",
        :role => role_of_user, :performed_at => Time.now , :ip_address => ip_address)
    end
  end

  # Predicate method for checking whether a user account with a login is locked or not.
  # Input :
  # login : login name/value
  # Output : true or false
  def self.is_locked?(login)
    is_locked = false
    user = User.find_by_login(login)
    if user
      is_locked = user.locked_at.present?
    end
    is_locked
  end

  def self.get_online_and_not_idle_and_idle_users(user_ids)
    online_user_ids, offline_user_ids, offline_user_logins = [], [], []
    user_hash = {}
    if user_ids
      users = User.where(:id => user_ids)
      user_hash, online_user_ids, offline_user_ids = get_online_and_offline_users(users)
      if online_user_ids.length > 0
        offline_user_ids << get_idle_users(online_user_ids)
      end
    end
    offline_user_ids = offline_user_ids.flatten
    if online_user_ids.length > 0
      online_user_ids = online_user_ids - offline_user_ids
    end
    if offline_user_ids.length > 0
      offline_user_logins = get_offline_user_logins(offline_user_ids, user_hash)
    end
    return online_user_ids, offline_user_ids, offline_user_logins
  end

  def self.get_online_and_offline_users(users)
    online_user_ids, offline_user_ids = [], []
    user_hash = {}
    if users.length > 0
      users.each do |user|
        user_hash[user.id] = user
        if user.login_status
          online_user_ids  << user.id
        else
          offline_user_ids  << user.id
        end
      end
    end
    return user_hash, online_user_ids, offline_user_ids
  end


  def self.get_idle_users(online_user_ids)
    idle_user_ids = []
    if online_user_ids.length > 0
      idle_users = IdleProcessor.where(:user_id => online_user_ids)
      idle_users.each do |idle_user|
        idle_user_ids << idle_user.user_id
      end
    end
    idle_user_ids
  end

  def self.get_offline_user_logins(offline_user_ids, user_hash)
    offline_user_logins = []
    if offline_user_ids.length > 0
      offline_user_ids.each do |user_id|
        if user_hash[user_id]
          offline_user_logins << user_hash[user_id].login
        end
      end
    end
    offline_user_logins
  end


end
