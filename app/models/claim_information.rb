class ClaimInformation < ActiveRecord::Base 
  establish_connection(ActiveRecord::Base.configurations["mpi_data_#{Rails.env}"])
  has_many :claim_service_informations
  has_one :insurance_payment_eob
  belongs_to :claim_file_information
  # Facility of the check/batch, for the processing of which this claim is used
  # to be set by the class that makes use of this attribute
  attr_accessor :facility
  alias_attribute :name, :billing_provider_organization_name
  alias_attribute :npi, :billing_provider_npi
  alias_attribute :tin, :billing_provider_tin
  alias_attribute :address_one, :billing_provider_address_one
  alias_attribute :city, :billing_provider_city
  alias_attribute :state, :billing_provider_state
  alias_attribute :zip_code, :billing_provider_zipcode
  ACTIVE = 1
  INACTIVE = 0
  DUPLICATE = 'Duplicate - outside parameters'
  REPLACED = 'Replaced - within parameters'
  CANCELED = 'Canceled by provider'
  
  # DCAP_REFACTOR BEGIN
  # Returns an array of records filtered based on acc_num
  scope :by_account_number, lambda { |acc_num, type_of_serach|
    if acc_num.blank?
      {:conditions => []}
    elsif type_of_serach == 'exact'
      {:conditions => ["patient_account_number = ?", acc_num]}
    elsif type_of_serach == 'begins_with'
      {:conditions => ["patient_account_number like ? ", "#{acc_num}%"]}
    end
  }

  scope :by_pt_first_name, lambda { |pt_first_name, type_of_serach|
    if pt_first_name.blank?
      {:conditions => []}
    elsif type_of_serach == 'exact'
      {:conditions => ["patient_first_name = ?", pt_first_name]}
    elsif type_of_serach == 'begins_with'
      {:conditions => ["patient_first_name like ? ", "#{pt_first_name}%"]}
    end
  }

  scope :by_pt_last_name, lambda { |pt_last_name, type_of_serach|
    if pt_last_name.blank?
      {:conditions => []}
    elsif type_of_serach == 'exact'
      {:conditions => ["patient_last_name = ?", pt_last_name]}
    elsif type_of_serach == 'begins_with'
      {:conditions => ["patient_last_name like ? ", "#{pt_last_name}%"]}
    end
  }

  scope :by_service_from_date, lambda {|svc_frm_date, type_of_serach|
    if svc_frm_date.blank?
      {:conditions => []}
    elsif type_of_serach == 'exact'
      {:conditions => ["service_from_date = ?", svc_frm_date], :joins => :claim_service_informations}
    elsif type_of_serach == 'begins_with'
      {:conditions => ["service_from_date like ? ", "#{svc_frm_date}%"], :joins => :claim_service_informations}
    end
  }

  # Executes search based on arguments supplied,
  # by calling build_and_execute_query
  # first performs an exact search
  # if results are blank then
  # performs a begins_with search
  def self.mpi_search(acc_num, f_name, l_name, date)
    results = build_and_execute_query(acc_num, f_name, l_name, date, 'exact')
    if results.blank?
      results = build_and_execute_query(acc_num, f_name, l_name, date, 'begins_with')
    end
    results
  end

  # DCAP_REFACTOR END


  # This method returns Bill Type which is a string generated by
  # appending claim frequency code to facility type code.
  # method assigns defaults to those values when they're nil or blank
  def bill_type
    claim_freq_code = (claim_frequency_type_code.blank? ? '1' : claim_frequency_type_code)
    fac_type_code = facility_type_code.blank? ? '13' : facility_type_code
    "#{claim_freq_code}#{fac_type_code}"
  end

  # Assigns weights to each 'claim_type'
  # based on value to be printed in 835
  def claim_type_weight
    case claim_type
    when 'Primary', 'P'
      1
    when 'Secondary', 'S'
      2
    when 'Tertiary', 'T'
      3
    end
  end

  # Returns the claim type to be set, for an eob
  # when an 837 is used to index the eob,
  # as per the interpretation of claim type from 837
  def claim_type_normalized
    case claim_type
    when 'P', 'Primary'
      'Primary'
    when 'S', 'Secondary'
      'Secondary'
    when 'T', 'Tertiary'
      'Tertiary'
    else
      nil
    end
  end
  
  # Returns the least service from date from
  # MPI service lines
  def least_date_for_mpi_svc_line
    least_service_from_date = self.claim_service_informations.minimum(:service_from_date)
  end
  
  # DCAP_REFACTOR BEGIN
  # Returns the consolidated version of all service_payment_eobs belonging to
  # the claims, of which the ids are passed as arguments
  # Logic used for consolidating:
  # least of 'service_from_date'
  # highest of service to date
  # CPT code to be populated only if they are same across all service lines
  # charges to be summed up
  def self.consolidated_svc_line(claim_info_ids)
    claims = ClaimInformation.find(claim_info_ids.to_a)
    claim_service_info_ids = claims.map{ |claim| claim.claim_service_informations.map(&:id)}
    claim_service_info_ids = claim_service_info_ids.join(",")
    unless claim_service_info_ids.blank?
      claim_service_information = ClaimServiceInformation.find(:first, :select => 
          "MIN(service_from_date) earliest_dt, MAX(service_to_date) latest_date,
           GROUP_CONCAT(cpt_hcpcts) cpts, SUM(charges) charges, SUM(days_units) units,
            GROUP_CONCAT(provider_control_number) provider_control_numbers",
        :conditions => "id IN (#{claim_service_info_ids})")
    end
    earliest_dt = claim_service_information.earliest_dt.to_s.slice(0,10)
    latest_date = claim_service_information.latest_date.to_s.slice(0,10)
    uniq_cpts = claim_service_information.cpts.split(",").first if !claim_service_information.cpts.blank?
    charges = claim_service_information.charges.to_f
    units = claim_service_information.units.to_i
    consolidated_svc_line = ClaimServiceInformation.new
    consolidated_svc_line.date_of_service_from = earliest_dt
    consolidated_svc_line.date_of_service_to = latest_date
    consolidated_svc_line.charges = charges
    consolidated_svc_line.days_units = units
    consolidated_svc_line.cpt_hcpcts = uniq_cpts
    consolidated_svc_line.provider_control_number = claim_service_information.provider_control_numbers.split(",").first if !claim_service_information.provider_control_numbers.blank?
    consolidated_svc_line
  end
  
  def self.compare_and_associate_claim_and_eob(claim_id, eob_id)
    svc_line_hash = ServicePaymentEob.get_the_service_payment_eobs_hash eob_id
    clm_svc_line_hash = ClaimServiceInformation.get_the_claim_service_info_hash claim_id
    associated_hash = match_the_service_lines svc_line_hash, clm_svc_line_hash
    unless associated_hash.empty?
      claim = self.find(claim_id)
      eob = InsurancePaymentEob.find(eob_id)
      eob.service_payment_eobs.update_all({:claim_service_information_id => nil, :updated_at => Time.now})
      link_the_service_lines associated_hash
      eob.claim_information = claim
      eob.save(:validate => false)
      return true
    end
    return false
  end
 
    
  def self.match_the_service_lines svc_line_hash, clm_svc_line_hash
    associated_hash = {}
    clm_svc_line_hash.each do |key, value|
      key_data = key.split(",")
      if svc_line_hash[key_data[0]]
        associated_hash[value] = svc_line_hash[key_data[0]]
      elsif  svc_line_hash[key_data[1]]
        associated_hash[value] = svc_line_hash[key_data[1]]
      end
    end
    return associated_hash.invert
  end

  def self.link_the_service_lines associated_hash
    associated_hash.each do |key, value|
      ServicePaymentEob.find(key).update_attribute(:claim_service_information_id, ClaimServiceInformation.find(value).id)
    end
  end
  
  # To read the contents of 837.md file
  def self.get_md_file_contents md_file
    unless File.readlines(md_file) == []
      read_md_file = File.read(md_file).split(";")
      if read_md_file[0].include?(".zip")
        zip_file_name = read_md_file[0].strip
        csv_file_name = zip_file_name[0...zip_file_name.length-4]
      else
        zip_file_name = nil
        csv_file_name = Time.now.strftime('%m%d%Y%H%M%S')
      end
      #file_arrival_time = Time.strptime(read_md_file[1].strip, '%m-%d-%Y %H:%M:%S').utc.strftime("%Y-%m-%d %H:%M:%S")
      file_arrival_time = Time.strptime(read_md_file[1].strip, '%m-%d-%Y %H:%M:%S')
      md5_hash_content = read_md_file[2].strip if read_md_file.length >= 3
    else
      zip_file_name = nil
      file_arrival_time = nil
      csv_file_name = Time.now.strftime('%m%d%Y%H%M%S')
      md5_hash_content = nil
    end
    return zip_file_name, file_arrival_time, csv_file_name, md5_hash_content
  end
  
  def find_key(attribute)
    unless additional_claim_informations.blank?
      if additional_claim_informations.has_key?(attribute)
        additional_claim_informations[attribute]
      else
        ""
      end
    end
  end

  def self.replace_patient_account_number_prefix client_code,patient_account_number
    if client_code == "HX"
      index_of_client_code = patient_account_number.index("X")
    end
    if index_of_client_code and index_of_client_code < 5
      patient_account_number.sub(patient_account_number[0..index_of_client_code],client_code)
    else
      patient_account_number
    end
  end
  
  # Sphinx index indication
  define_index ActiveRecord::Base.configurations["mpi_data_#{Rails.env}"]["database"] do
    indexes :patient_account_number, :sortable => true
    indexes :patient_last_name, :sortable => true
    indexes :patient_first_name, :sortable => true
    indexes :insured_id, :sortable => true
    indexes :payer_name
    indexes self.claim_service_informations.service_from_date, :as => :service_from_date, :sortable => true
    indexes self.claim_service_informations.cpt_hcpcts, :as => :cpt_code
    indexes :claim_statement_period_start_date, :as => :claim_from_date
    indexes :total_charges
    indexes :facility_id, :as => :facilityid
    has :facility_id
    has :client_id
    has :created_at
    has :claim_file_information_id
    set_property :field_weights => {:patient_account_number => 25, :patient_last_name => 20,:patient_first_name =>10,:service_from_date => 10,:insured_id => 25,:total_charges => 10}
    # set_property :delta => :datetime, :threshold => 1.hour
  end
  
  protected
  # Chains the namedscope calls used in MPI Search
  # and applies them on the claim_nformations table,
  # returns the result
  # For exmaple, returns the result set obtained by:
  # by_account_number('12345', 'exact').by_pt_first_name('John', 'exact').
  # by_pt_last_name('Galt', 'exact').by_service_from_date('2010-09-16', 'exact')
  # type of search can be 'exact' or 'begins_with'
  def self.build_and_execute_query(acc_num, f_name, l_name, date, type_of_search)
    ClaimInformation.by_account_number("#{acc_num.to_s}", "#{type_of_search}").
      by_pt_first_name("#{f_name.to_s}", "#{type_of_search}").
      by_pt_last_name("#{l_name.to_s}", "#{type_of_search}").
      by_service_from_date("#{date.to_s}", "#{type_of_search}")
  end
  # DCAP_REFACTOR END

  def self.normalize_date(date)
    if (date != "mm/dd/yy" && !date.blank? )
      date_parts = date.to_s.split("/")
      date_parts[2] + "-" + date_parts[0] + "-" + date_parts[1]
    end
  end

  def self.mpi_search_for_sphinx(facility_id,client_id,account_number,patient_last_name,patient_first_name,service_from_date,insured_id,total_charges,page,exact_serach = nil,payer_name = nil, sort_mode_for_header = nil, sort_by = nil,mpi_serach_facility_group = nil,cpt_code = nil)
    mpi_conditions = []
    condition_list = []
    condition_list << "("
    condition_list << "@patient_account_number #{Riddle.escape(account_number)}"  unless account_number.blank?
    condition_list << "@patient_last_name #{Riddle.escape(patient_last_name)}"    unless patient_last_name.blank?
    condition_list << "@patient_first_name #{Riddle.escape(patient_first_name)}"  unless patient_first_name.blank?
    condition_list << "@service_from_date #{service_from_date}"    unless service_from_date.blank?
    condition_list << "@payer_name #{Riddle.escape(payer_name)}"  unless payer_name.blank?
    condition_list << "@cpt_code #{Riddle.escape(cpt_code)}"  unless cpt_code.blank?
    condition_list << "@total_charges #{Riddle.escape(sprintf('%.2f',total_charges))}"    unless total_charges.blank?
    condition_list << "@insured_id #{Riddle.escape(insured_id)}"    unless insured_id.blank?
    condition_list << ")"
   
   
    if(condition_list.length > 2)
      if exact_serach
        if(exact_serach == "1")
          mpi_conditions = condition_list.join(" ")
        else
          mpi_conditions = condition_list.join("|")
          mpi_conditions = mpi_conditions.sub("(|","(")
          mpi_conditions = mpi_conditions.sub("|)",")")
        end
      end
      if !(mpi_serach_facility_group.blank?)
        mpi_serach_facility=  mpi_serach_facility_group.split(' ')
        mpi_serach_facility_array = []
        mpi_serach_facility.each do|array|
          mpi_serach_facility_array << array.to_i
        end
      end
      if(!facility_id.blank?)
        if(!mpi_serach_facility.blank?)
          sort = {:facility_id => mpi_serach_facility_array}
        else
          sort = {:facility_id => "#{facility_id}"}
        end
      elsif(!client_id.blank?)
        sort = {:client_id => "#{client_id}"}
      end

      if(sort_by.blank?)
        sort_by = @weight
        sort_mode_for ='desc'
      else
        sort_by = sort_by.to_s.to_sym
        sort_mode_for = sort_mode_for_header.to_s.to_sym
      end

      @mpi_results = ClaimInformation.search mpi_conditions ,
        :per_page => 15, :page => page,:with => sort,
        :start => true, :match_mode => :extended,:order =>:patient_last_name,:sort_mode => 'desc',
        :index => get_mpi_index_name,
        :classes => [ClaimInformation], :populate => true ,:field_weights => {:patient_account_number => 25, :patient_last_name => 20,:patient_first_name =>10,:service_from_date => 10,:insured_id => 25,:total_charges => 10},
        :order => sort_by.to_s.to_sym,
        :sort_mode => sort_mode_for
        

    else
      @mpi_results = []
    end
    @mpi_results.compact!
    @mpi_results
  end
end
